#!/usr/bin/env python3

# (c) 2018-2019 Vladimír Štill

import os
import os.path
import re
import subprocess
import sys
import tempfile
import textwrap
from typing import List, Pattern, TextIO

from typing_extensions import Final

FilePath = str

if len(sys.argv) < 3:
    print(f"usage: {sys.argv[0]} TEACHER_FILE STUDENT_FILE [-IDIR ...] "
          "[-pFD] [--hint]", file=sys.stderr)
    sys.exit(1)

teacher : Final[str] = sys.argv[1]
student : Final[str] = sys.argv[2]
hint : bool = False
include : List[str] = []
journal_fd : int = 2

for i in range(3, len(sys.argv)):
    v = sys.argv[i]
    if v == "--hint":
        hint = True
    if v.startswith("-p"):
        journal_fd = int(v[2:])
    elif v.startswith("-I") or v.startswith("-i"):
        include.append(v[2:])

ALL_EXTS : Final[List[str]] = ["NoMonomorphismRestriction"]
ST_EXTS : Final[List[str]] = ["Safe"] + ALL_EXTS
T_EXTS : Final[List[str]] = ["TemplateHaskell", "Unsafe", "ExplicitForAll",
                             "ScopedTypeVariables", "DataKinds",
                             "StandaloneDeriving", "DeriveDataTypeable"] \
                             + ALL_EXTS
MAIN_EXTS : Final[List[str]] = T_EXTS

OPT_R : Final[Pattern[str]] = re.compile("-- @ +([^:]*)(?:: +(.*))?")
LIST_SPLIT_R : Final[Pattern[str]] = re.compile(" *, *| +")
ERR_HEADER : Final[Pattern[str]] = re.compile(r"^([^:]*)[.]hs:[0-9]*:[0-9]*:")
IGNORE : Final[Pattern[str]] = re.compile(r"^(-- .*)?\s*$")
AST_CHECK_DECL : Final[Pattern[str]] = re.compile(r"^([^\s:]*)\s*::\s*ASTCheck")
GHC_LINE_ERR : Final[Pattern[str]] = re.compile(r"^[0-9]*\s*\|")


class TestConf:
    def __init__(self) -> None:
        self.inject : str = ""
        self.reqire_type : bool = False
        self.allow_imports : bool = True
        self.typecmp : bool = False
        self.typecmp_num_types : int = 0
        self.exts : List[str] = []
        self.imports : List[str] = []
        self.compiled : bool = False
        self.reflection : bool = False
        self.ast_checks : List[str] = []


def warn(msg : str) -> None:
    print("W: " + msg, file=sys.stderr)


def write_type(dst : TextIO, t : str, i : int) -> None:
    dst.write("t{} :: {}\nt{} = undefined\n".format(i, t, i))


def val2bool(val : str) -> bool:
    return val.lower() == "yes" or val.lower() == "true"


def mkTeacherFile(srcFile : FilePath, dstFile : FilePath) -> TestConf:
    with open(dstFile, "w") as dst:
        with open(srcFile, "r") as src:
            conf = TestConf()

            dst.write("{-# LANGUAGE " + ", ".join(T_EXTS) + " #-}\n\n")
            dst.write("module Teacher where\n\n")

            inject : bool = False
            inject_end : bool = False

            for l in src:
                match = OPT_R.fullmatch(l.rstrip())
                if match:
                    key : str = match[1]
                    val : str = match[2]

                    if key == "exts":
                        conf.exts += LIST_SPLIT_R.split(val)
                    elif key == "INJECT BEGIN":
                        assert not inject, "inject inside inject"
                        inject = True
                    elif key == "INJECT END":
                        assert inject, "inject end without start"
                        inject = False
                        inject_end = True
                    elif key == "require type":
                        conf.reqire_type = val2bool(val)
                    elif key == "allow imports":
                        conf.allow_imports = val2bool(val)
                    elif key == "typecmp":
                        conf.typecmp = True
                    elif key == "compiled":
                        conf.compiled = val2bool(val)
                    elif key == "reflection":
                        conf.reflection = val2bool(val)
                    elif key == "import":
                        conf.imports += LIST_SPLIT_R.split(val)
                    else:
                        warn("unknown option '{}: {}'".format(key, val))

                if conf.reflection:
                    match = AST_CHECK_DECL.search(l)
                    if match:
                        conf.ast_checks.append(match[1])

                if inject:
                    conf.inject += l
                if inject_end:
                    conf.inject += l
                    inject_end = False

                if not conf.typecmp:
                    dst.write(l)
                else:
                    if not IGNORE.match(l):
                        write_type(dst, l, conf.typecmp_num_types)
                        conf.typecmp_num_types += 1

            return conf


def mkStudentFile(srcFile : FilePath, dstFile : FilePath, conf : TestConf) \
        -> None:
    with open(dstFile, "w") as dst:
        # one skipping BOM if present
        with open(srcFile, "r", encoding='utf-8-sig') as src:
            exts_string = ", ".join(ST_EXTS + conf.exts)
            dst.write("{-# LANGUAGE " + exts_string + " #-}\n\n")
            if conf.reqire_type:
                dst.write("{-# OPTIONS_GHC -Werror=missing-signatures #-}\n\n")
            dst.write("module Student where\n\n")

            if conf.inject:
                dst.write(conf.inject)

            if not conf.allow_imports:
                dst.write("no_imports_for_student_allowed :: ()\n"
                          "no_imports_for_student_allowed = ()\n\n")

            dst.write('{-# LINE 1 "IS.hs" #-}\n')
            type_idx = 0
            if not conf.typecmp:
                for l in src:
                    dst.write(l)
            else:
                for l in src:
                    if not IGNORE.match(l):
                        write_type(dst, l, type_idx)
                        type_idx += 1


def mkStudentReflectorFile(srcFile : FilePath, dstDir : FilePath,
                           conf : TestConf) -> None:
    with open(os.path.join(dstDir, "StudentReflector.hs"), "w") as dst:
        with open(srcFile, "r", encoding='utf-8-sig') as src:
            dst.write(textwrap.dedent("""\
                {-# LANGUAGE TemplateHaskell #-}

                module StudentReflector (
                    studentAST, runASTCheck,
                    module Test.Expr.Reflection
                    ) where

                import Test.Expr.Reflection

                studentAST :: Q [Dec]
                studentAST = [d|
                """))

            for l in src:
                dst.write("    " + l)
            dst.write("    |]\n\n")
            dst.write(textwrap.dedent("""\
                runASTCheck :: ASTCheck -> Q [Dec]
                runASTCheck check = studentAST >>= check >> pure []
                """))
    with open(os.path.join(dstDir, "StudentASTChecks.hs"), "w") as dst:
        dst.write(textwrap.dedent("""\
            {-# LANGUAGE TemplateHaskell #-}

            module StudentASTChecks () where

            import StudentReflector ( runASTCheck )
            import qualified Teacher

            """))

        for c in conf.ast_checks:
            dst.write(f"$(runASTCheck Teacher.{c})\n")


def mkMainFile(filename : FilePath, conf : TestConf) -> None:
    reflect = "import qualified StudentASTChecks" if conf.reflection else ""
    with open(filename, "w") as dst:
        dst.write("{-# LANGUAGE " + ", ".join(MAIN_EXTS) + "#-}\n")
        dst.write(f"""
module Main ( main ) where

import qualified Teacher
import safe qualified Student
{reflect}
import Test.Expr
import Test.Expr.Config
import Test.Expr.Types ( TypeOrder ( TEqual ) )
import Data.Maybe ( catMaybes )
import Data.Tuple.TH.Curry
import Language.Haskell.TH ( Exp ( ConE ) )
import Test.QuickCheck.Convertible ( convert )
import qualified Test.QuickCheck.Modifiers
import qualified Test.QuickCheck.Range
import System.Exit
import Control.Monad
""")
        for imp in conf.imports:
            dst.write("import qualified {}\n".format(imp))

        if not conf.typecmp:
            dst.write(f"""
$(testMainEx (TestConfig
      (ConfigEntry Expression $(extractOption "expr")
      : ConfigEntry TypeOrd $(extractOptionDef "typeOrder" (ConE 'TEqual))
      : ConfigEntry JournalFd {journal_fd}
      : catMaybes [ConfigEntry TestPattern <$> $(extractOptionMaybe "pattern"),
                   ConfigEntry DegenType <$> $(extractOptionMaybe "degenType")
                  ])))
""")
        else:
            dst.write("main :: IO ()\nmain = do\n")
            for i in range(conf.typecmp_num_types):
                dst.write("    $(testType \"t{}\")\n".format(i))


with tempfile.TemporaryDirectory(prefix="hsExprTest.") as wd:
    conf = mkTeacherFile(teacher, os.path.join(wd, "Teacher.hs"))
    mkStudentFile(student, os.path.join(wd, "Student.hs"), conf)
    if conf.reflection:
        mkStudentReflectorFile(student, wd, conf)
    os.chdir(wd)

    mkMainFile("Main.hs", conf)

    invocation : List[str] = [f"-i{x}" for x in include] + ["-dynamic"]
    execution : List[str] = []

    if conf.typecmp:
        # just compile, does not need to run
        invocation.insert(0, "ghc")
        invocation.extend(["-e", "return ()"])
        if hint:
            invocation.append("Student.hs")  # just parse student's file
        else:
            invocation.append("Main.hs")  # acutally do the comparison
    else:  # expression comparison
        if hint:
            invocation.insert(0, "ghc")
            invocation.extend(["-e", "return ()"])
        else:
            if conf.compiled:
                invocation[:0] = ["ghc", "-o", "test", "-odir", ".",
                                  "-hidir", ".", "-O2"]
                execution = ["./test"]
            else:
                invocation.insert(0, "runghc")

        invocation.append("Main.hs")
    pass_fds = [journal_fd] if journal_fd != 2 else []
    r = subprocess.run(invocation, stdin=subprocess.DEVNULL,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                       pass_fds=pass_fds, encoding="utf-8")

    print(r.stdout, end='', flush=True)
    hide = False
    ast_check = False
    hidden = 0
    for l in r.stderr.splitlines():
        m = ERR_HEADER.match(l)
        if m:
            hide = False
            ast_check = False
            if hint and (m[1] != "IS" and m[1] != "StudentASTChecks"):
                hide = True
                hidden += 1
            elif m[1] == "StudentASTChecks":
                ast_check = True
        if hide:
            print(l, file=sys.stderr, flush=True)
        elif ast_check and GHC_LINE_ERR.search(l) is not None:
            print(l, file=sys.stderr, flush=True)
        else:
            print(l, flush=True)
    if hidden > 0:
        print(f"+ {hidden} more errors hidden in syntax check mode, check "
              "that your function is correctly typed and named", flush=True)

    is_hint = "hint" if hint else "no hint"
    if not hint and len(execution) != 0:
        if r.returncode != 0:
            print(f"failed (compilation): {r.returncode} ({is_hint})",
                  file=sys.stderr, flush=True)
            sys.exit(2)
        r = subprocess.run(execution, stdin=subprocess.DEVNULL,
                           stdout=sys.stdout, stderr=sys.stdout,
                           pass_fds=pass_fds, encoding="utf-8")

    if r.returncode != 0:
        if r.returncode == -14:
            print("\nTIMEOUT -- total time limit exceeded", flush=True)
        print(f"failed: {r.returncode} ({is_hint})",
              file=sys.stderr, flush=True)
        sys.exit(1)
    sys.exit(0)

# vim: colorcolumn=80 expandtab sw=4 ts=4
