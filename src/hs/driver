#!/usr/bin/env python3

# (c) 2018-2020 Vladimír Štill

import os
import os.path
import re
import subprocess
import sys
import tempfile
import textwrap
import yaml
import evalconf
from typing import List, Pattern, TextIO, Optional, Dict, Any, TypeVar

from typing_extensions import Final

T = TypeVar("T")
FilePath = str

if len(sys.argv) < 3:
    print(f"usage: {sys.argv[0]} TEACHER_FILE STUDENT_FILE [-IDIR ...] "
          "[-pFD] [-cCONFIG] [--hint]", file=sys.stderr)
    sys.exit(1)

teacher : Final[str] = sys.argv[1]
student : Final[str] = sys.argv[2]
hint : bool = False
include : List[str] = []
journal_fd : int = 2
_config : Optional[Dict[str, Any]] = None

for i in range(3, len(sys.argv)):
    v = sys.argv[i]
    if v == "--hint":
        hint = True
    if v.startswith("-p"):
        journal_fd = int(v[2:])
    elif v.startswith("-I") or v.startswith("-i"):
        include.append(v[2:])
    elif v.startswith("-c"):
        with open(v[2:], "r") as h:
            _config = yaml.safe_load(h)

if _config is None:
    _config = evalconf.EvalConf().from_source_file(teacher).config


ALL_EXTS : Final[List[str]] = []
ST_EXTS : Final[List[str]] = ["Safe"] + ALL_EXTS
T_EXTS : Final[List[str]] = ["TemplateHaskell", "Unsafe", "ExplicitForAll",
                             "ScopedTypeVariables", "DataKinds",
                             "StandaloneDeriving", "DeriveDataTypeable"] \
                             + ALL_EXTS
MAIN_EXTS : Final[List[str]] = T_EXTS

OPT_R : Final[Pattern[str]] = re.compile("-- @ +([^:]*)(?:: +(.*))?")
LIST_SPLIT_R : Final[Pattern[str]] = re.compile(" *, *| +")
ERR_HEADER : Final[Pattern[str]] = re.compile(r"^([^:]*)[.]hs:[0-9]*:[0-9]*:")
IGNORE : Final[Pattern[str]] = re.compile(r"^(-- .*)?\s*$")
AST_CHECK_DECL : Final[Pattern[str]] = re.compile(r"^([^\s:]*)\s*::\s*ASTCheck")
GHC_LINE_ERR : Final[Pattern[str]] = re.compile(r"^[0-9]*\s*\|")
COMPILE_LINE : Final[Pattern[str]] = re.compile(r"^(\[[0-9]+\s+of\s+[0-9]+\]|Linking .* ...)")


class TestConf:
    def __init__(self, config : dict) -> None:
        self.inject : str = ""
        self.typecmp : bool = False
        self.typecmp_num_types : int = 0
        self.ast_checks : List[str] = []
        self.config = config

    def reflection(self) -> bool:
        return self.get("reflection", False)

    def compiled(self) -> bool:
        return self.get("compiled", False)

    def exts(self) -> List[str]:
        return self.get("exts", [])

    def student_exts(self) -> List[str]:
        return ST_EXTS + self.exts() + self.get("student exts", [])

    def teacher_exts(self) -> List[str]:
        return T_EXTS + self.exts() + self.get("teacher exts", [])

    def main_exts(self) -> List[str]:
        return MAIN_EXTS + self.exts() + self.get("main exts", [])

    def imports(self) -> List[str]:
        return self.get("imports", [])

    def require_type(self) -> bool:
        return self.get("require type", False)

    def allow_imports(self) -> bool:
        return self.get("allow imports", True)

    def warnings(self) -> List[str]:
        return self.get("warnings", [])

    def get(self, key : str, default : T) -> T:
        return self.config.get(key, default)


def warn(msg : str) -> None:
    print("W: " + msg, file=sys.stderr)


def write_type(dst : TextIO, t : str, i : int) -> None:
    dst.write("t{} :: {}\nt{} = undefined\n".format(i, t, i))


def val2bool(val : str) -> bool:
    return val.lower() == "yes" or val.lower() == "true"


def mkTeacherFile(srcFile : FilePath, dstFile : FilePath) -> TestConf:
    with open(dstFile, "w") as dst:
        with open(srcFile, "r") as src:
            assert _config is not None
            conf = TestConf(_config)

            dst.write("{-# LANGUAGE " + ", ".join(conf.teacher_exts())
                                      + " #-}\n\n")
            dst.write("module Teacher where\n\n")

            inject : bool = False
            inject_end : bool = False

            for l in src:
                match = OPT_R.fullmatch(l.rstrip())
                if match:
                    key : str = match[1]

                    if key == "INJECT BEGIN":
                        assert not inject, "inject inside inject"
                        inject = True
                    elif key == "INJECT END":
                        assert inject, "inject end without start"
                        inject = False
                        inject_end = True
                    elif key == "typecmp":
                        conf.typecmp = True

                if conf.reflection():
                    match = AST_CHECK_DECL.search(l)
                    if match:
                        conf.ast_checks.append(match[1])

                if inject:
                    conf.inject += l
                if inject_end:
                    conf.inject += l
                    inject_end = False

                if not conf.typecmp:
                    dst.write(l)
                else:
                    if not IGNORE.match(l):
                        write_type(dst, l, conf.typecmp_num_types)
                        conf.typecmp_num_types += 1

            return conf


def mkStudentFile(srcFile : FilePath, dstFile : FilePath, conf : TestConf) \
        -> None:
    with open(dstFile, "w") as dst:
        # one skipping BOM if present
        with open(srcFile, "r", encoding='utf-8-sig') as src:
            exts_string = ", ".join(conf.student_exts())
            dst.write("{-# LANGUAGE " + exts_string + " #-}\n\n")
            if conf.require_type():
                dst.write("{-# OPTIONS_GHC -Werror=missing-signatures #-}\n\n")
            if conf.warnings():
                ws = " ".join(f"-W{w}" for w in conf.warnings())
                dst.write("{-# OPTIONS_GHC " + ws + " #-}")
            dst.write("module Student where\n\n")

            if conf.inject:
                dst.write(conf.inject)

            if not conf.allow_imports():
                dst.write("no_imports_for_student_allowed :: ()\n"
                          "no_imports_for_student_allowed = ()\n\n")

            dst.write('{-# LINE 1 "IS.hs" #-}\n')
            type_idx = 0
            if not conf.typecmp:
                for l in src:
                    dst.write(l)
            else:
                for l in src:
                    if not IGNORE.match(l):
                        write_type(dst, l, type_idx)
                        type_idx += 1


def mkStudentReflectorFile(srcFile : FilePath, dstDir : FilePath,
                           conf : TestConf) -> None:
    with open(os.path.join(dstDir, "StudentReflector.hs"), "w") as dst:
        with open(srcFile, "r", encoding='utf-8-sig') as src:
            dst.write(textwrap.dedent("""\
                {-# LANGUAGE TemplateHaskell #-}

                module StudentReflector (
                    studentAST, runASTCheck,
                    module Test.Expr.Reflection
                    ) where

                import Test.Expr.Reflection

                studentAST :: Q [Dec]
                studentAST = [d|
                """))

            for l in src:
                dst.write("    " + l)
            dst.write("\n    |]\n\n")
            dst.write(textwrap.dedent("""\
                runASTCheck :: ASTCheck -> Q [Dec]
                runASTCheck check = studentAST >>= check >> pure []
                """))
    with open(os.path.join(dstDir, "StudentASTChecks.hs"), "w") as dst:
        dst.write(textwrap.dedent("""\
            {-# LANGUAGE TemplateHaskell #-}

            module StudentASTChecks () where

            import StudentReflector ( runASTCheck )
            import qualified Teacher

            """))

        for c in conf.ast_checks:
            dst.write(f"$(runASTCheck Teacher.{c})\n")


def mkMainFile(filename : FilePath, conf : TestConf) -> None:
    reflect = ""
    if conf.reflection():
        reflect = "import qualified StudentASTChecks"
    with open(filename, "w") as dst:
        dst.write("{-# LANGUAGE " + ", ".join(conf.main_exts()) + "#-}\n")
        dst.write(f"""
module Main ( main ) where

import qualified Teacher
import safe qualified Student
{reflect}
import Test.Expr
import Test.Expr.Config
import Test.Expr.Types ( TypeOrder ( TEqual ) )
import Data.Maybe ( catMaybes )
import Data.Tuple.TH.Curry
import Language.Haskell.TH ( Exp ( ConE ) )
import Test.QuickCheck.Convertible ( convert )
import qualified Test.QuickCheck.Modifiers
import qualified Test.QuickCheck.Range
import System.Exit
import Control.Monad
""")
        for imp in conf.imports():
            dst.write("import qualified {}\n".format(imp))

        if not conf.typecmp:
            dst.write(f"""
$(testMain (TestConfig
      ( ConfigEntry TypeOrd $(extractOptionDef "typeOrder" (ConE 'TEqual))
      : ConfigEntry JournalFd {journal_fd}
      : catMaybes [ConfigEntry TestPattern <$> $(extractOptionMaybe "pattern"),
                   ConfigEntry Expression <$> $(extractOptionMaybe "expr"),
                   ConfigEntry DegenType <$> $(extractOptionMaybe "degenType")
                  ])))
""")
        else:
            dst.write("main :: IO ()\nmain = do\n")
            for i in range(conf.typecmp_num_types):
                dst.write("    $(testType \"t{}\")\n".format(i))


with tempfile.TemporaryDirectory(prefix="hsExprTest.") as wd:
    conf = mkTeacherFile(teacher, os.path.join(wd, "Teacher.hs"))
    mkStudentFile(student, os.path.join(wd, "Student.hs"), conf)
    if conf.reflection():
        mkStudentReflectorFile(student, wd, conf)
    os.chdir(wd)

    mkMainFile("Main.hs", conf)

    invocation : List[str] = [f"-i{x}" for x in include] + ["-dynamic"]
    execution : List[str] = []

    if conf.typecmp:
        # just compile, does not need to run
        invocation.insert(0, "ghc")
        invocation.extend(["-e", "return ()"])
        if hint:
            invocation.append("Student.hs")  # just parse student's file
        else:
            invocation.append("Main.hs")  # acutally do the comparison
    else:  # expression comparison
        if hint:
            invocation.insert(0, "ghc")
            invocation.extend(["-e", "return ()"])
        else:
            if conf.compiled():
                invocation[:0] = ["ghc", "-o", "test", "-odir", ".",
                                  "-hidir", ".", "-O2"]
                execution = ["./test"]
            else:
                invocation.insert(0, "runghc")

        invocation.append("Main.hs")
    pass_fds = [journal_fd] if journal_fd != 2 else []
    r = subprocess.run(invocation, stdin=subprocess.DEVNULL,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                       pass_fds=pass_fds, encoding="utf-8")

    if conf.compiled():
        for l in r.stdout.splitlines():
            if COMPILE_LINE.search(l) is None:
                print(l, flush=True)
            else:
                print(l, flush=True, file=sys.stderr)
    else:
        print(r.stdout, end='', flush=True)
    hide = False
    ast_check = False
    hidden = 0
    for l in r.stderr.splitlines():
        m = ERR_HEADER.match(l)
        if m:
            hide = False
            ast_check = False
            if hint and (m[1] != "IS" and m[1] != "StudentASTChecks"):
                hide = True
                hidden += 1
            elif m[1] == "StudentASTChecks":
                ast_check = True
        if hide:
            print(l, file=sys.stderr, flush=True)
        elif ast_check and GHC_LINE_ERR.search(l) is not None:
            print(l, file=sys.stderr, flush=True)
        else:
            print(l, flush=True)
    if hidden > 0:
        print(f"+ {hidden} more errors hidden in syntax check mode, check "
              "that your function is correctly typed and named", flush=True)

    is_hint = "hint" if hint else "no hint"
    if not hint and len(execution) != 0:
        if r.returncode != 0:
            print(f"failed (compilation): {r.returncode} ({is_hint})",
                  file=sys.stderr, flush=True)
            sys.exit(2)
        r = subprocess.run(execution, stdin=subprocess.DEVNULL,
                           stdout=sys.stdout, stderr=sys.stdout,
                           pass_fds=pass_fds, encoding="utf-8")

    if r.returncode != 0:
        if r.returncode == -14:
            print("\nTIMEOUT -- total time limit exceeded", flush=True)
        print(f"failed: {r.returncode} ({is_hint})",
              file=sys.stderr, flush=True)
        sys.exit(1)
    sys.exit(0)

# vim: colorcolumn=80 expandtab sw=4 ts=4
